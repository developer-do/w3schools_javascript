<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Page Title</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" media="screen" href="../main.css" />
</head>
<body>
  <h1>JavaScript Function Invocation</h1>
  <hr>
  
  <p>JavaScript 함수내의 코드는 "무언가"가 호출 할 때 실행됩니다.</p>
  <hr>

  <h2>JavaScript 함수 호출하기</h2>
  <p>함수가 정의 될 때 함수내의 코드는 실행되지 않습니다.</p>
  <p>함수 내부의 코드는 함수가 호출 될 때 실행됩니다.</p>
  <p>"call a function"대신에 "invoke a function"이라는 용어를 사용하는 것이 일반적입니다.</p>
  <p>또한 함수 호출, 함수 시작 또는 함수 실행 이라고 하는 것이 일반적입니다.</p>
  <p>이 튜토리얼에서, 우리는 사용하는 호출되지 않고 호출 될 수 있기 때문에 호출할 것이다 ???</p>
  <hr>


  <h2>함수를 함수로 호출</h2>
  <pre>
    function myFunction (a, b) {
      return a * b;
    }
    myFunction(10, 2);    // WIll return 20
  </pre>
  <p>위의 함수는 어떤 객체에도 속하지 않습니다. 그러나 JavaScript에는 항상 기본 전역 객체가 있습니다.</p>
  <p>HTML에서 기본 전역 객체는 HTML 페이지 자체이므로 위의 함수는 HTML 페이지에 속합니다.</p>
  <p>브라우저에서 페이지 객체는 브라우저 창입니다. 위의 함수는 자동으로 window function이 됩니다.</p>
  <p>myFunction()와 window.myFunction()은 같은 함수 입니다.</p>
  <pre>
    function myFunction(a, b) {
      return a * b;
    }
    window myFunction(10, 2);   // Will also return 20
  </pre>
  <p class="yellow">
    이것은 JavaScript 함수를 호출하는 일반적인 방법이지만 아주좋은 방법은 아닙니다.<br>
    전역변수, 메소드 또는 함수는 전역 객체에 이름 충돌 및 버그를 쉽게 만들 수 있습니다.
  </p>
  <hr>

  <h2>this 키워드</h2>
  <p>JavaScript에서 this를 호출하는 것은 현재 코드를 "소유하고 있는" 객체입니다.</p>
  <p>이 값은 함수에서 사용 될 때 함수를 "소유"하는 객체입니다.</p>
  <p class="yellow">this는 변수가 아니면 값을 변경할 수 없습니다.</p>
  <hr>

  <h2>전역 객체</h2>
  <p>함수가 소유 대상없이 호출 될 때의 값 this는 전역 객체가 된다.</p>
  <p>웹 브라우저에서 전역 객체는 브라우저 창입니다.</p>
  <p>이 예제는 window객체를 this의 값으로 반환합니다.</p>
  <pre>
    var x = myFunction();

    function myFunction(){
      return this;
    }
  </pre>
  <p class="yellow">
    함수를 전역 함수로 호출하면 this값이 window를 가리킵니다.<br>
    변수로 윈도우 객체를 사용하면 쉽게 프로그램을 중단 시킬 수 있습니다.
  </p>

  <hr>

  <h2>메소드로서의 함수 호출</h2>
  <p>JavaScirpt에서는 함수를 객체 메소드로 정의할 수 있습니다.</p>
  <p>다음 예제에서는 두 개의 속성(firstName 및 lastName)과 하나의 메서드 (fullName)를 사용하여 객체(myObject)를 만듭니다.</p>
  <pre>
    var myObject = {
      firstName:"John",
      lastName: "Doe",
      fullName: function () {
        return this.firstName + " " + this.lastName;
      }
    }
    myObject.fullName();
  </pre>
  <p>fullName method는 함수다. 그 함수는 객체에 속하며 그 객체는 myObject이다.</p>
  <p>이것을 자바스크립트 코드를 "소유"하는 객체입니다. 이때의 onwer는 myObject입니다.</p>
  <p class="yellow">함수를 객체 메소드로 호출하면 this값은 이 객체 자체가 됩니다.</p>
  <hr>

  <h2>함수 생성자로 함수 호출하기</h2>
  <p>함수 호출이 new 키워드 보다 먼저 나오면 생성자 호출입니다.</p>
  <p>새 함수를 만드는 것처럼 보이지만 JavaScript 함수는 객체이기 때문에 실제로 새 객체를 만듭니다.</p>

  <pre>
    // This is a function constructor:
    function myFunction(arg1, arg2) {
      this.firstName = arg1;
      this.lastName = arg2;
    }

    // This creates a new object
    var x = new myFunction("John", "Doe");
    x.firstName;    // will return "John";
  </pre>
  <p>생성자 호출은 새 객체를 만듭니다. 새 객체는 생성자에서 속성과 메서드를 상속받습니다.</p>
  <p class="yellow">
    생성자의 this키워드에 값이 없습니다.<br>
    this 값은 함수가 호출될 때 생성되는게 새 객체일 것이다.
  </p>














</body>
</html>
<script src="main.js"></script>